---
description: Documenting your thinking process, research and implementation plans
globs: 
alwaysApply: true
---

During your interaction with the user, if you find anything reusable in this project (e.g. version of a library, model name), especially about a fix to a mistake you made or a correction you received, you should take note in the `Lessons` section in the [scratchpad.mdc](mdc:.cursor/rules/scratchpad.mdc) file so you will not make the same mistake again.

# Lessons

## User Specified Lessons

- You have an env in ./.env Use it.
- Read the file before you try to edit it.
- Keep all files under 100 lines of code to maintain readability and follow single responsibility principle
- **CRITICAL**: Always reference and follow `typescript.coding.principle.mdc` when writing ANY code
  - Follow KISS, DRY, SRP, Open-Closed principles
  - One function per file (file name matches function name)
  - Use emojis in log messages (‚úÖ ‚ùå ‚ö†Ô∏è ‚ÑπÔ∏è üîÑ üìä etc.)
  - NO `.js` extensions in TypeScript imports
  - Types go in `types/` folder
  - Supabase queries in `supabase/[table_name]/` folders
  - Keep functions small, focused, and pure when possible
    
## Cursor learned

You should use the [scratchpad.mdc](mdc:scratchpad.md) file as a Scratchpad to organize your thoughts. Especially when you receive a new task, you should first review the content of the Scratchpad, clear old different task if necessary, first explain the task, and plan the steps you need to take to complete the task. You can use todo markers to indicate the progress, e.g.
[X] Task 1
[ ] Task 2

**IMPORTANT**: Update the Scratchpad CONTINUOUSLY as you work:
- When you start a new task ‚Üí review, clear old tasks, plan steps
- When you complete a subtask ‚Üí mark it complete immediately
- When you make progress ‚Üí update the status section
- When you finish a milestone ‚Üí reflect and plan next steps
- When planning next actions ‚Üí always refer to Scratchpad first

Also update the progress of the task in the Scratchpad when you finish a subtask.
Especially when you finished a milestone, it will help to improve your depth of task accomplishment to use the Scratchpad to reflect and plan.
The goal is to help you maintain a big picture as well as the progress of the task. Always refer to the Scratchpad when you plan the next step.

### Envio GraphQL Query Patterns
- **Query Method**: Use `node-fetch` to POST GraphQL queries to Envio endpoint (despite constant name `GRPC_ENDPOINT`, it's actually a GraphQL endpoint)
- **Entity Names**: Use exact entity names from Envio schema with underscores and capitals (e.g., `InProcess_Collections`, not `InProcessCollections`)
- **Field Names**: Use snake_case field names in GraphQL queries (e.g., `chain_id`, `created_at`, `token_id`)
- **GraphQL Variables**: Pass `limit`, `offset`, and `chainId` as variables in the query
- **Ordering**: Use `order_by: { created_at: desc }` for consistent pagination
- **Filtering**: Use `where: { chain_id: { _eq: $chainId } }` for chain filtering

### Pagination Pattern
- **Limit/Offset**: Use limit/offset pagination (default limit: 1000)
- **HasNextPage Detection**: If returned results length equals limit, there might be more pages (set `hasNextPage = true`)
- **NextOffset**: Calculate as `offset + limit`
- **Pagination Loop**: Use `while (hasNextPage)` loop to fetch all pages

### Type Definitions
- **Location**: Define Envio entity types in `types/envio.ts`
- **Naming**: Use `EntityName_t` suffix (e.g., `InProcess_Collections_t`)
- **Fields**: Match GraphQL schema exactly, use `readonly` modifier
- **Optional Fields**: Use `| undefined` for nullable fields (e.g., `payout_recipient: string | undefined`)

### Constants and Configuration
- **Location**: Define constants in `lib/consts.ts`
- **Environment Variables**: Use `dotenv.config()` at top of consts file, then access via `process.env.VAR_NAME`
- **Network Config**: Use `viem/chains` to import chain definitions (e.g., `base`, `baseSepolia`)
- **Endpoint Pattern**: Envio GraphQL endpoint format: `https://indexer.dev.hyperindex.xyz/{INDEXER_ID}/v1/graphql`
- **Indexing Intervals**: `INDEX_INTERVAL_MS` (1000ms) defined in `lib/consts.ts` for delay between indexing cycles

### Multi-Chain Indexing Pattern
- **Parallel Execution**: Use `Promise.all()` to index multiple chains simultaneously
- **Chain IDs**: Extract from `NETWORKS` array using `.map(network => network.id)`
- **Results Aggregation**: Use `.flat()` to combine results from all chains into single array
- **Logging**: Log per-chain results and total count

### File Structure Patterns
- **Query Functions**: `lib/grpc/InProcess_[Entity]/query[Entity].ts` - single GraphQL query with pagination params
- **Index Functions**: `lib/grpc/InProcess_[Entity]/index[Entity].ts` - orchestrates fetching and syncing to Supabase with incremental indexing
- **Batch Processing**: `lib/[entity]/process[Entity]InBatches.ts` - handles batch upserts to Supabase
- **Multi-Chain Functions**: `lib/[entity]/execute[Entity]IndexingParallel.ts` - handles parallel indexing across chains
- **Supabase Queries**: `lib/supabase/in_process_[table]/` - organized by table name, one function per file

### Incremental Indexing Pattern
- **Purpose**: Only fetch records updated since last sync to minimize data transfer and processing
- **selectMaxUpdatedAt() Function**: 
  - Location: `lib/supabase/in_process_[table]/selectMaxUpdatedAt.ts`
  - Returns: Maximum `updated_at` timestamp in milliseconds (epoch), or `null` if no records exist
  - Error Handling: Handles `PGRST116` error code (no records found) gracefully by returning `null`
  - Conversion: Converts Supabase ISO timestamp string to milliseconds using `new Date(data.updated_at).getTime()`
- **Timestamp Conversion Flow**:
  1. Supabase stores `updated_at` as ISO string
  2. `selectMaxUpdatedAt()` converts ISO ‚Üí milliseconds (epoch)
  3. `toChainTimestamp()` converts milliseconds ‚Üí chain timestamp (seconds)
  4. GraphQL query uses `minUpdatedAt` (chain timestamp) to filter records
- **Usage in Index Functions**:
  ```typescript
  const maxUpdatedAtSupabase = await selectMaxUpdatedAt();
  const minUpdatedAtEnvio = toChainTimestamp(
    maxUpdatedAtSupabase ?? new Date(0).getTime()
  );
  // Use minUpdatedAtEnvio in GraphQL query where clause
  ```
- **Fallback**: If no records exist (`null`), uses `new Date(0).getTime()` to fetch all records from beginning

### TypeScript Coding Principles Quick Reference
**ALWAYS CHECK `typescript.coding.principle.mdc` BEFORE WRITING CODE!**

Key principles to follow:
- **KISS**: Keep it simple, avoid over-engineering
- **DRY**: Don't repeat yourself, extract common logic
- **SRP**: One function per file, one responsibility per function
- **File Organization**: 
  - One function per file (file name = function name)
  - Types in `types/` folder
  - Supabase queries in `supabase/[table_name]/` folders
- **Imports**: NO `.js` extensions in TypeScript imports
- **Logging**: Use emojis (‚úÖ ‚ùå ‚ö†Ô∏è ‚ÑπÔ∏è üîÑ üìä üîç üíæ)
- **Functions**: Small, focused, pure when possible

---

# Current Task: Moments Indexing

## Task Overview
Building new architecture to index `InProcess_Moments` from Envio GraphQL to Supabase. This follows the same pattern as Collections indexing and is part of migrating from legacy indexer to new architecture.

**Last Updated**: Current session - Moments indexing implementation completed

## Progress

### Completed ‚úÖ
- [X] Added `InProcess_Moments_t` type to `types/envio.ts`
- [X] Created GraphQL query function (`lib/grpc/InProcess_Moments/queryMoments.ts`)
- [X] Created moments indexing function (`lib/grpc/InProcess_Moments/indexMoments.ts`)
- [X] Created batch processing function (`lib/moments/processMomentsInBatches.ts`)
- [X] Created multi-chain indexing function (`lib/moments/executeMomentsIndexingParallel.ts`)
- [X] Created Supabase mapping function (`lib/supabase/in_process_moments/mapMomentsToSupabase.ts`)
- [X] Created Supabase upsert function (`lib/supabase/in_process_moments/upsertMoments.ts`)
- [X] Created Supabase selectMaxUpdatedAt function (`lib/supabase/in_process_moments/selectMaxUpdatedAt.ts`)
- [X] Created collection ID resolver utility (`lib/supabase/in_process_collections/getCollectionId.ts`)
- [X] Integrated moments indexing into main indexer (`indexer.ts`)
- [X] All files follow TypeScript coding principles (one function per file, <100 lines, emojis in logs)

### Key Implementation Details
- **Collection ID Resolution**: Moments reference collections by ID (not address), so we resolve collection address+chain_id to collection ID using `getCollectionId()`
- **Max Supply Conversion**: Converts `max_supply` from string (BigInt from GraphQL) to number for Supabase
- **Incremental Indexing**: 
  - Both Collections and Moments use `selectMaxUpdatedAt()` to fetch only records updated since last sync
  - Pattern: Supabase ISO timestamp ‚Üí milliseconds ‚Üí chain timestamp (seconds) ‚Üí GraphQL filter
  - Handles empty table gracefully (returns `null`, falls back to epoch 0)
- **Conflict Resolution**: 
  - Collections: Uses `address, chain_id` as unique constraint
  - Moments: Uses `collection, token_id` as unique constraint

## Architecture Notes
- New code is in `lib/` directory (not `legacy/`)
- Using Envio GraphQL endpoint directly (not gRPC)
- Following single responsibility principle (one function per file)
- All files kept under 100 lines
- Moments indexing runs in parallel with Collections indexing
