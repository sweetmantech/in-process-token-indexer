---
description: Documenting your thinking process, research and implementation plans
globs: 
alwaysApply: true
---

During your interaction with the user, if you find anything reusable in this project (e.g. version of a library, model name), especially about a fix to a mistake you made or a correction you received, you should take note in the `Lessons` section in the [scratchpad.mdc](mdc:.cursor/rules/scratchpad.mdc) file so you will not make the same mistake again.

# Lessons

## User Specified Lessons

- You have an env in ./.env Use it.
- Read the file before you try to edit it.
- Keep all files under 100 lines of code to maintain readability and follow single responsibility principle
- **CRITICAL**: Always reference and follow `typescript.coding.principle.mdc` when writing ANY code
  - Follow KISS, DRY, SRP, Open-Closed principles
  - One function per file (file name matches function name)
  - Use emojis in log messages (‚úÖ ‚ùå ‚ö†Ô∏è ‚ÑπÔ∏è üîÑ üìä etc.)
  - NO `.js` extensions in TypeScript imports
  - Types go in `types/` folder
  - Supabase queries in `supabase/[table_name]/` folders
  - Keep functions small, focused, and pure when possible
    
## Cursor learned

You should use the [scratchpad.mdc](mdc:scratchpad.md) file as a Scratchpad to organize your thoughts. Especially when you receive a new task, you should first review the content of the Scratchpad, clear old different task if necessary, first explain the task, and plan the steps you need to take to complete the task. You can use todo markers to indicate the progress, e.g.
[X] Task 1
[ ] Task 2

**IMPORTANT**: Update the Scratchpad CONTINUOUSLY as you work:
- When you start a new task ‚Üí review, clear old tasks, plan steps
- When you complete a subtask ‚Üí mark it complete immediately
- When you make progress ‚Üí update the status section
- When you finish a milestone ‚Üí reflect and plan next steps
- When planning next actions ‚Üí always refer to Scratchpad first

Also update the progress of the task in the Scratchpad when you finish a subtask.
Especially when you finished a milestone, it will help to improve your depth of task accomplishment to use the Scratchpad to reflect and plan.
The goal is to help you maintain a big picture as well as the progress of the task. Always refer to the Scratchpad when you plan the next step.

### Envio GraphQL Query Patterns
- **Query Method**: Use `node-fetch` to POST GraphQL queries to Envio endpoint (despite constant name `GRPC_ENDPOINT`, it's actually a GraphQL endpoint)
- **Entity Names**: Use exact entity names from Envio schema with underscores and capitals (e.g., `InProcess_Collections`, not `InProcessCollections`)
  - **Payments Entity**: Use `InProcess_Payments` (NOT `InProcess_ERC20RewardsDeposit` - this was renamed in the schema)
- **Field Names**: Use snake_case field names in GraphQL queries (e.g., `chain_id`, `created_at`, `token_id`)
- **GraphQL Variables**: Pass `limit`, `offset`, and `minTimestamp` as variables in the query
  - **Type Definition**: `GraphQLQueryParams` interface defines concrete variable types:
    ```typescript
    variables: {
      limit: number;      // Required (defaults handled in query functions)
      offset: number;     // Required (defaults handled in query functions)
      minTimestamp: number; // Required (for incremental indexing)
    }
    ```
  - Query functions handle defaults (limit: 1000, offset: 0) before passing to `queryGraphQL`
- **Ordering**: Use `order_by: { created_at: desc }` for consistent pagination
- **Filtering**: Use `where: { updated_at: { _gt: $minTimestamp } }` for incremental indexing

### Pagination Pattern
- **Limit/Offset**: Use limit/offset pagination (default limit: 1000, default offset: 0)
  - Defaults are handled in individual query functions (e.g., `queryCollections`, `queryAdmins`)
  - `queryGraphQL` receives concrete values (no defaults, uses destructuring: `const { limit, offset } = variables`)
- **HasNextPage Detection**: If returned results length equals limit, there might be more pages (set `hasNextPage = true`)
- **NextOffset**: Calculate as `offset + limit`
- **Pagination Loop**: Use `while (hasNextPage)` loop to fetch all pages

### Type Definitions
- **Location**: Define Envio entity types in `types/envio.ts`
- **Naming**: Use `EntityName_t` suffix (e.g., `InProcess_Collections_t`)
- **Fields**: Match GraphQL schema exactly, use `readonly` modifier
- **Optional Fields**: Use `| undefined` for nullable fields (e.g., `payout_recipient: string | undefined`)

### Constants and Configuration
- **Location**: Define constants in `lib/consts.ts`
- **Environment Variables**: Use `dotenv.config()` at top of consts file, then access via `process.env.VAR_NAME`
- **Network Config**: Use `viem/chains` to import chain definitions (e.g., `base`, `baseSepolia`)
- **Endpoint Pattern**: Envio GraphQL endpoint format: `https://indexer.dev.hyperindex.xyz/{INDEXER_ID}/v1/graphql`
- **Indexing Intervals**: `INDEX_INTERVAL_MS` (1000ms) defined in `lib/consts.ts` for delay between indexing cycles

### Multi-Chain Indexing Pattern
- **Parallel Execution**: Use `Promise.all()` to index multiple chains simultaneously
- **Chain IDs**: Extract from `NETWORKS` array using `.map(network => network.id)`
- **Results Aggregation**: Use `.flat()` to combine results from all chains into single array
- **Logging**: Log per-chain results and total count

### File Structure Patterns
- **Query Functions**: `lib/grpc/query[Entity].ts` - single GraphQL query with pagination params
  - Functions handle default values for `limit` (1000) and `offset` (0)
  - Pass concrete values to `queryGraphQL` with `GraphQLQueryParams` interface
  - All query functions follow same pattern: `limit = 1000, offset = 0, minTimestamp: number`
- **GraphQL Query Interface**: `lib/grpc/queryGraphQL.ts` - generic GraphQL query function
  - Uses concrete `GraphQLQueryParams` interface with typed variables
  - Variables are required (no optional fields), defaults handled by query functions
  - Uses destructuring: `const { limit, offset } = variables`
- **Indexer Files**: `lib/indexers/[entity]Indexer.ts` - exports `[entity]Indexer` instance (e.g., `adminsIndexer`, `collectionsIndexer`)
  - Indexer instance is created with `queryFn`, `processBatchFn`, `selectMaxTimestampFn`, and `indexName`
  - `indexer.ts` calls `execute()` directly on indexer instances
  - All indexer files are organized in `lib/indexers/` folder
- **IndexFactory**: `lib/indexers/IndexFactory.ts` - factory class for creating indexer instances
- **Batch Processing**: `lib/[entity]/process[Entity]InBatches.ts` - handles batch upserts to Supabase
- **Multi-Chain Functions**: `lib/[entity]/execute[Entity]IndexingParallel.ts` - handles parallel indexing across chains
- **Supabase Queries**: `lib/supabase/in_process_[table]/` - organized by table name, one function per file
- **ID Resolution Utilities**: `lib/[entity]/get[Entity]IdMap.ts` - resolves foreign key relationships (e.g., collection address ‚Üí collection ID, moment lookup)
- **Select Functions**: `lib/supabase/in_process_[table]/select[Entity].ts` - queries entities with joins (e.g., `selectMoments` with collection join)

### Incremental Indexing Pattern
- **Purpose**: Only fetch records updated since last sync to minimize data transfer and processing
- **selectMaxUpdatedAt() Function**: 
  - Location: `lib/supabase/in_process_[table]/selectMaxUpdatedAt.ts`
  - Returns: Maximum `updated_at` timestamp in milliseconds (epoch), or `null` if no records exist
  - Error Handling: Handles `PGRST116` error code (no records found) gracefully by returning `null`
  - Conversion: Converts Supabase ISO timestamp string to milliseconds using `new Date(data.updated_at).getTime()`
- **Alternative Timestamp Fields**: Some entities don't have `updated_at` field
  - **Moment Admins**: Uses `granted_at` instead of `updated_at` for incremental indexing
  - Location: `lib/supabase/in_process_moment_admins/selectMaxGrantedAt.ts`
  - Same pattern: ISO ‚Üí milliseconds ‚Üí chain timestamp (seconds) ‚Üí GraphQL filter
  - GraphQL query uses `minGrantedAt` instead of `minUpdatedAt`
- **Timestamp Conversion Flow**:
  1. Supabase stores timestamp as ISO string
  2. `selectMax[Timestamp]()` converts ISO ‚Üí milliseconds (epoch)
  3. `toChainTimestamp()` converts milliseconds ‚Üí chain timestamp (seconds)
  4. GraphQL query uses `min[Timestamp]` (chain timestamp) to filter records
- **Usage in Index Functions**:
  ```typescript
  const maxTimestampSupabase = await selectMaxUpdatedAt(); // or selectMaxGrantedAt()
  const minTimestampEnvio = toChainTimestamp(
    maxTimestampSupabase ?? new Date(0).getTime()
  );
  // Use minTimestampEnvio in GraphQL query where clause
  ```
- **Fallback**: If no records exist (`null`), uses `new Date(0).getTime()` to fetch all records from beginning

### Entity-Specific Incremental Indexing Patterns
- **Standard Pattern**: Most entities use `updated_at` for incremental indexing
  - Use `selectMaxUpdatedAt()` function
  - GraphQL query filters with `where: { updated_at: { _gt: $minUpdatedAt } }`
- **Alternative Timestamp Fields**: Some entities use different timestamp fields
  - **Moment Admins**: Uses `granted_at` instead of `updated_at`
    - Create `selectMaxGrantedAt()` function (same pattern as `selectMaxUpdatedAt`)
    - GraphQL query filters with `where: { granted_at: { _gt: $minGrantedAt } }`
  - **Future entities**: Check Envio schema to identify the appropriate timestamp field
- **Pattern Consistency**: Always follow the same conversion flow regardless of timestamp field name
  1. Supabase ISO string ‚Üí milliseconds (epoch)
  2. Milliseconds ‚Üí chain timestamp (seconds) via `toChainTimestamp()`
  3. Use in GraphQL query filter

### TypeScript Coding Principles Quick Reference
**ALWAYS CHECK `typescript.coding.principle.mdc` BEFORE WRITING CODE!**

Key principles to follow:
- **KISS**: Keep it simple, avoid over-engineering
- **DRY**: Don't repeat yourself, extract common logic
- **SRP**: One function per file, one responsibility per function
- **File Organization**: 
  - One function per file (file name = function name)
  - Types in `types/` folder
  - Supabase queries in `supabase/[table_name]/` folders
  - Business logic utilities in `lib/[entity]/` folders (e.g., `getMomentIdMap`)
- **Imports**: 
  - NO `.js` extensions in TypeScript imports
  - **Use alias imports (`@/`) instead of relative imports (`../`) when importing from other directories**
  - Example: `import { INDEX_INTERVAL_MS } from '@/lib/consts'` ‚úÖ (not `'../consts'` ‚ùå)
  - Relative imports (`./`) are acceptable for same-directory imports
- **Logging**: Use emojis (‚úÖ ‚ùå ‚ö†Ô∏è ‚ÑπÔ∏è üîÑ üìä üîç üíæ)
- **Functions**: Small, focused, pure when possible

---

# Current Task: Code Refactoring - Reorganize Indexer Files ‚úÖ COMPLETED

## Task Overview
Reorganized indexer files by moving them from `lib/grpc/InProcess_*/` to `lib/indexers/` and renaming them to follow a consistent `[...]Indexer` naming pattern. Also moved `IndexFactory` to the `indexers` folder for better organization.

**Status**: ‚úÖ **COMPLETED**
**Last Updated**: Just completed

## Progress

### Completed ‚úÖ
- [X] Moved all index files from `lib/grpc/InProcess_*/` to `lib/indexers/`
- [X] Renamed files to `[...]Indexer.ts` pattern:
  - `indexAdmins.ts` ‚Üí `adminsIndexer.ts`
  - `indexCollections.ts` ‚Üí `collectionsIndexer.ts`
  - `indexComments.ts` ‚Üí `commentsIndexer.ts`
  - `indexMoments.ts` ‚Üí `momentsIndexer.ts`
  - `indexSales.ts` ‚Üí `salesIndexer.ts`
- [X] Updated exports to match new naming (e.g., `adminsIndexer`, `collectionsIndexer`)
- [X] Moved `IndexFactory` from `lib/IndexFactory.ts` to `lib/indexers/IndexFactory.ts`
- [X] Updated all imports in indexer files to use new `IndexFactory` location
- [X] Updated `indexer.ts` to import from new locations and use new constant names

### Key Changes
- **File Organization**: All indexer files now live in `lib/indexers/` folder
- **Naming Convention**: Files and exports follow `[...]Indexer` pattern for consistency
- **IndexFactory Location**: Moved to `lib/indexers/IndexFactory.ts` to co-locate with indexers
- **Import Updates**: Updated query function imports from relative (`./querySales`) to absolute (`@/lib/grpc/querySales`)
- **Usage**: `indexer.ts` now imports and uses `adminsIndexer`, `collectionsIndexer`, etc.

## Architecture Notes
- All indexer files are now organized in a single `lib/indexers/` directory
- Consistent naming pattern makes it easier to find and understand indexer files
- `IndexFactory` is co-located with indexers for better code organization
- Query functions remain in `lib/grpc/InProcess_*/` directories (separation of concerns)

---

# Previous Task: Sales Indexing ‚úÖ COMPLETED

## Task Overview
Built new architecture to index `InProcess_Sales` from Envio GraphQL to Supabase. This follows the same pattern as other entity indexing but maps sales to moments (collection+chain_id+token_id ‚Üí moment ID) and uses `created_at` for incremental indexing.

**Status**: ‚úÖ **COMPLETED**
**Last Updated**: Implementation complete

## Progress

### Completed ‚úÖ
- [X] Added `InProcess_Sales_t` type to `types/envio.ts`
- [X] Created GraphQL query function (`lib/grpc/InProcess_Sales/querySales.ts`)
- [X] Created sales indexing function (`lib/grpc/InProcess_Sales/indexSales.ts`)
- [X] Created batch processing function (`lib/sales/processSalesInBatches.ts`)
- [X] Created execute function (`lib/sales/executeSalesIndexing.ts`)
- [X] Created Supabase mapping function (`lib/sales/mapSalesToSupabase.ts`)
- [X] Created Supabase upsert function (`lib/supabase/in_process_sales/upsertSales.ts`)
- [X] Created selectMaxCreatedAt function (`lib/supabase/in_process_sales/selectMaxCreatedAt.ts`)
- [X] Integrated sales indexing into main indexer (`indexer.ts`)
- [X] All files follow TypeScript coding principles (one function per file, <100 lines, emojis in logs)

### Key Implementation Details
- **Moment ID Resolution**: Sales reference moments by ID, so we resolve collection+chain_id+token_id ‚Üí moment ID using `getMomentIdMap()` from `lib/momentAdmins/`
  - Converts sales to moment admins format (with proper type casting) to reuse the existing utility
- **Incremental Indexing**: Uses `created_at` for incremental indexing (sales don't have `updated_at` field)
  - Pattern: Supabase ISO timestamp ‚Üí milliseconds ‚Üí chain timestamp (seconds) ‚Üí GraphQL filter
  - Uses `selectMaxCreatedAt()` function
- **Mapping**: 
  - `id` (from Envio) ‚Üí `id` (in Supabase, used as primary key)
  - `collection` (address) + `chain_id` + `token_id` ‚Üí `moment` (UUID in Supabase)
  - `currency`, `funds_recipient` (lowercased) ‚Üí same fields in Supabase
  - BigInt fields converted to numbers: `sale_start`, `sale_end`, `max_tokens_per_address`, `price_per_token`
  - `created_at` (chain timestamp) ‚Üí ISO timestamp
- **Conflict Resolution**: Uses `id` as unique constraint (Envio ID is used as primary key)

## Architecture Notes
- New code is in `lib/` directory (not `legacy/`)
- Using Envio GraphQL endpoint directly (not gRPC)
- Following single responsibility principle (one function per file)
- All files kept under 100 lines
- Reuses `getMomentIdMap` utility from `lib/momentAdmins/`
- Sales indexing runs in parallel with other indexers (currently enabled in indexer.ts)

---

# Previous Task: Moment Comments Indexing ‚úÖ COMPLETED

## Task Overview
Built new architecture to index `InProcess_Moment_Comments` from Envio GraphQL to Supabase. This follows the same pattern as Moment Admins indexing but maps comments to moments (collection+chain_id+token_id ‚Üí moment ID).

**Status**: ‚úÖ **COMPLETED**
**Last Updated**: Implementation complete

## Progress

### Completed ‚úÖ
- [X] Added `InProcess_Moment_Comments_t` type to `types/envio.ts`
- [X] Created GraphQL query function (`lib/grpc/InProcess_Moment_Comments/queryMomentComments.ts`)
- [X] Created moment comments indexing function (`lib/grpc/InProcess_Moment_Comments/indexMomentComments.ts`)
- [X] Created batch processing function (`lib/momentComments/processMomentCommentsInBatches.ts`)
- [X] Created execute function (`lib/momentComments/executeMomentCommentsIndexing.ts`)
- [X] Created Supabase mapping function (`lib/momentComments/mapMomentCommentsToSupabase.ts`)
- [X] Created Supabase upsert function (`lib/supabase/in_process_moment_comments/upsertComments.ts`)
- [X] Created selectMaxCommentedAt function (`lib/supabase/in_process_moment_comments/selectMaxCommentedAt.ts`)
- [X] Integrated moment comments indexing into main indexer (`indexer.ts`)
- [X] All files follow TypeScript coding principles (one function per file, <100 lines, emojis in logs)

### Key Implementation Details
- **Moment ID Resolution**: Comments reference moments by ID, so we resolve collection+chain_id+token_id ‚Üí moment ID using `getMomentIdMap()` from `lib/momentAdmins/`
  - Converts moment comments to moment admins format (with proper type casting) to reuse the existing utility
- **Incremental Indexing**: Uses `commented_at` for incremental indexing (similar to moment admins using `granted_at`)
  - Pattern: Supabase ISO timestamp ‚Üí milliseconds ‚Üí chain timestamp (seconds) ‚Üí GraphQL filter
  - Uses `selectMaxCommentedAt()` function
- **Mapping**: 
  - `id` (from Envio) ‚Üí `id` (in Supabase, used as primary key)
  - `sender` (from Envio) ‚Üí `artist_address` (in Supabase, lowercased)
  - `collection` (address) + `chain_id` + `token_id` ‚Üí `moment` (UUID in Supabase)
  - `comment` (from Envio) ‚Üí `comment` (in Supabase, nullable)
  - `commented_at` (chain timestamp) ‚Üí ISO timestamp
- **Conflict Resolution**: Uses `id` as unique constraint (Envio ID is used as primary key)
- **Artist Resolution**: Ensures artists exist in Supabase before upserting comments (via `ensureArtists`)

## Architecture Notes
- New code is in `lib/` directory (not `legacy/`)
- Using Envio GraphQL endpoint directly (not gRPC)
- Following single responsibility principle (one function per file)
- All files kept under 100 lines
- Reuses `getMomentIdMap` utility from `lib/momentAdmins/`
- Moment comments indexing runs in parallel with other indexers (currently enabled in indexer.ts)

## Progress

### Completed ‚úÖ
- [X] Added `InProcess_Collection_Admins_t` type to `types/envio.ts`
- [X] Created GraphQL query function (`lib/grpc/InProcess_Collection_Admins/queryCollectionAdmins.ts`)
- [X] Created collection admins indexing function (`lib/grpc/InProcess_Collection_Admins/indexCollectionAdmins.ts`)
- [X] Created batch processing function (`lib/collectionAdmins/processCollectionAdminsInBatches.ts`)
- [X] Created multi-chain indexing function (`lib/collectionAdmins/executeCollectionAdminsIndexing.ts`)
- [X] Created Supabase mapping function (`lib/collectionAdmins/mapCollectionAdminsToSupabase.ts`)
- [X] Created Supabase upsert function (`lib/supabase/in_process_collection_admins/upsertCollectionAdmins.ts`)
- [X] Created selectMaxGrantedAt function (`lib/supabase/in_process_collection_admins/selectMaxGrantedAt.ts`)
- [X] Added `in_process_collection_admins` table to Supabase types (`lib/supabase/types.ts`)
- [X] Integrated collection admins indexing into main indexer (`indexer.ts`)
- [X] All files follow TypeScript coding principles (one function per file, <100 lines, emojis in logs)

### Key Implementation Details
- **Collection ID Resolution**: Collection admins reference collections by ID, so we resolve collection address+chain_id ‚Üí collection ID using `getCollectionIdMap()` from `lib/collections/`
- **No Token ID**: Collection admins are collection-level (no `token_id` field in Envio entity)
- **Incremental Indexing**: Uses `granted_at` for incremental indexing (same as moment admins)
  - Pattern: Supabase ISO timestamp ‚Üí milliseconds ‚Üí chain timestamp (seconds) ‚Üí GraphQL filter
  - Uses `selectMaxGrantedAt()` function
- **Mapping**: 
  - `admin` (from Envio) ‚Üí `artist_address` (in Supabase, lowercased)
  - `collection` (address) + `chain_id` ‚Üí `collection` (UUID in Supabase)
  - `granted_at` (chain timestamp) ‚Üí ISO timestamp
  - `hidden` defaults to `false`
- **Conflict Resolution**: Uses `collection, artist_address` as unique constraint
- **Supabase Table**: Added `in_process_collection_admins` table definition to types with:
  - `collection` (FK to `in_process_collections.id`)
  - `artist_address` (FK to `in_process_artists.address`)
  - `granted_at`, `hidden`, `id`

## Architecture Notes
- New code is in `lib/` directory (not `legacy/`)
- Using Envio GraphQL endpoint directly (not gRPC)
- Following single responsibility principle (one function per file)
- All files kept under 100 lines
- Reuses `getCollectionIdMap` utility from `lib/collections/`
- Collection admins indexing runs in parallel with other indexers (currently enabled in indexer.ts)
