---
alwaysApply: true
---

# TypeScript Coding Principles

## Core Principles

### KISS Principle (Keep It Simple, Stupid)
- Write simple, straightforward code that is easy to understand
- Avoid unnecessary complexity and over-engineering
- Prefer clear, readable solutions over clever ones
- If a solution seems too complicated, simplify it

### DRY Principle (Don't Repeat Yourself)
- Avoid code duplication
- Extract common logic into reusable functions or utilities
- Use shared constants, types, and helpers
- Refactor repeated patterns into abstractions

### SRP Principle (Single Responsibility Principle)
- Each function, class, or module should have one clear responsibility
- `A function` MUST do `one thing(file)` and do it well
- If a function does multiple things, split it into smaller functions
- Keep functions focused and cohesive

### Open-Closed Principle
- Code should be open for extension but closed for modification
- Design functions and classes to be extensible without changing existing code
- Use interfaces, abstract classes, and dependency injection to enable extension
- Prefer composition over modification when adding new features

## File Organization

### One Function Per File
- Each function should be defined in its own file
- The file name should match the function name (e.g., `getMaxBlockTimestamp.ts` exports `getMaxBlockTimestamp`)
- This improves:
  - Code discoverability
  - Easier testing
  - Better code organization
  - Reduced merge conflicts

### Supabase Query Functions
- All pure Supabase query functions must be organized in the `supabase` folder
- Group functions by table: `supabase/[table_name]/`
- Example structure:
  ```
  supabase/
    in_process_tokens/
      selectTokens.ts
      upsertTokens.ts
    in_process_payments/
      selectPayments.ts
      upsertPayments.ts
  ```
- Keep query functions pure and focused on database operations
- Separate business logic from database queries

### Types
- All types should be defined in a `types` folder
- Example structure:
  ```
  types/
    envio.ts
    moments.ts
  ```
- Keep type definitions organized and easily discoverable
- Export types from a central location when shared across modules

## Best Practices

### Function Design
- Keep functions small and focused
- Use descriptive names that clearly indicate purpose
- Prefer pure functions when possible (no side effects)
- Handle errors explicitly and gracefully

### Type Safety
- Use TypeScript types and interfaces consistently
- Avoid `any` types; use `unknown` when type is truly unknown
- Leverage TypeScript's type inference where appropriate
- Define types in the `types` folder (see File Organization section)

### Code Structure
- Group related functionality together
- Maintain clear separation of concerns
- Use consistent naming conventions
- Follow the existing project structure patterns

### Imports
- **Do NOT use `.js` extensions in TypeScript import statements**
- Use TypeScript file extensions (`.ts`) or no extension when importing TypeScript files
- Example: `import { something } from './utils/helper'` âœ…
- Avoid: `import { something } from './utils/helper.js'` âŒ

### Logging
- **Use emojis widely in log messages with logical meaning**
- Emojis help developers quickly identify log types and meanings at a glance
- Use consistent emoji patterns for similar log types:
  - âœ… Success/completion: `âœ…`, `ğŸ‰`, `âœ¨`
  - âŒ Error/failure: `âŒ`, `ğŸš¨`, `ğŸ’¥`
  - âš ï¸ Warning: `âš ï¸`, `ğŸ””`
  - â„¹ï¸ Info: `â„¹ï¸`, `ğŸ“`, `ğŸ’¡`
  - ğŸ”„ Processing/retry: `ğŸ”„`, `â³`, `ğŸ”„`
  - ğŸ“Š Data/metrics: `ğŸ“Š`, `ğŸ“ˆ`, `ğŸ“‰`
  - ğŸ” Debug/search: `ğŸ”`, `ğŸ”`
  - ğŸ’¾ Database/IO: `ğŸ’¾`, `ğŸ“¥`, `ğŸ“¤`
- Example: `console.log('âœ… Successfully indexed 100 tokens')`
- Example: `console.error('âŒ Failed to connect to database')`
- Example: `console.log('ğŸ”„ Retrying request (attempt 2/3)')`
